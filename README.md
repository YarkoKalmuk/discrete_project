# Служба швидкого реагування

Стихійні лиха, такі як повені чи цунамі, створюють серйозні проблеми для транспортної інфраструктури, особливо в регіонах, де населені пункти мають обмежену кількість доріг для сполучення. Відновлення зв’язності транспортної мережі є необхідним для забезпечення доступу до гуманітарної допомоги, евакуації та відновлення нормального життя.

Наш проєкт спрямований на вирішення цієї проблеми шляхом розробки програми, яка:

1. Визначає населені пункти, що залишилися без доступу до обласних центрів.
2. Знаходить мінімальну сумарну довжину доріг, які необхідно відновити для повного відновлення транспортного сполучення.

Протягом кількох тижнів, ми з командою працювали над реалізацією цього завдання. Нашою головною метою було створити програму, яка б не лише ефективно виконувала свою функцію, але й була зручною у використанні. 

### Інструкція з користування

Для того, щоб скористатись цією програмою вам потрібно:

- Записати у файл граф, у якого ребра — дороги, а вершини — міста.
- Після цього, у вас є два варіанти скористатися функціоналом:
    - За допомогою командного рядка (модуль `argparse`). У цьому випадку, Вам потрібно вказати шлях до 2 файлів: один з графом, інший - куди записувати результат. Приклади виклику через командний рядок для файлів input_example та output_example наведені нижче:
        
        Для користувачів Windows:
        
        ```cli
        py main.py --input input_example --output output_example
        ```
        
        Для користувачів MacOS:
        
        ```cli
        python3 main.py --input input_example --output output_example
        ```
        
    - Крім того, програмою можна скористуватися за допомогою  `cli ui` . Для цього Вам потрібно буде запустити файл без додаткових аргументів у середовищі, де встановленні бібліотеки `networkx` та `matplotlib`, які відповідають за візуалізацію графу.
- Якщо скористатися першим методом, у файл `output_example` будуть записані відокремлені від регіонального центру міста, та спосіб найоптимальнішого відновлення доріг.
- Скориставшись другим методом, користувач через простий та зрозумілий інтерфейс отримає можливість візуалізувати свій граф, отримати список відокремлених населених пунктів, список та вартість доріг, які забезпечують найоптимальніший спосіб відновлення сполучень, та можливість візуалізувати цей спосіб відновлення.

### **Розробка функцій**

Після першої зустрічі кожен з нас почав працювати над своїми частинами проєкту.

**Функція read_file:**

Спочатку було розроблено функцію для зчитування файлу, обробки та аналізу інформації про транспортні з'єднання між населеними пунктами. Вона працює з файлом, що містить дані про зв'язки між різними типами населених пунктів та довжини доріг між ними, а також зберігає інформацію про заблоковані дороги. Ось як ця функція реалізована та що вона робить:

Спершу функція відкриває файл у режимі читання та задаються змінні: `blocked` — збереження заблокованих доріг, `all_road` — збереження всіх доріг між населеними пунктами, `status_road` — булева змінна, яка визначає, чи ми зараз обробляємо звичайні дороги (True) чи заблоковані (False).

Цикл проходиться по кожній лінії та якщо у файлі зустрічається рядок "Blocked", функція змінює `status_road` на `False`, вказуючи, що всі наступні рядки описують заблоковані дороги.

Згодом рядок розбивається на частини (наприклад: рядок `"city A, village B, 10”` розбивається на `["city", "A", "village", "B", "10"]` та формуються ключі для міст (`key1` для першого міста:  `("city", "A")` ; `key2` для другого міста `("village", "B")`).

Якщо `status_road` — True: 

- якщо `key1` ще немає у словнику `all_road`, створюється новий запис, де `key1` є ключем, а `key2` — елементом множини, що представляє всі з'єднані місця.
- якщо `key1` уже існує в `all_road`, до множини з'єднань додається `key2`.

Аналогічно обробляється зворотний зв’язок, додаючи `key1` у список з'єднань для `key2`.

Якщо `status_road` — False: у множину `blocked` додається кортеж, який містить перше місто, друге місто та довжину дороги.

У результаті функція повертає список: перший елемент — словник `all_road`, що містить усі доступні дороги; другий елемент — множина `blocked`, що містить всі заблоковані дороги.

**Функція disconnected_places:**

Ця функція визначає всі відокремлені місця на основі наданих даних про з'єднання між ними та заблоковані дороги. Вона здійснює пошук `компонент зв'язності` в графі, що складається з місць, з’єднаних дорогами, причому заблоковані дороги не враховуються в пошуку.

Спершу створюємо порожній словник для зберігання фільтрованих з'єднань `roads = {}` . Згодом перебираємо кожне місце та його з'єднання: ми фільтруємо з'єднання, перевіряючи чи не є дорога заблокованою і записуємо відфільтровані з'єднання в новий словник.

Далі ми перебираємо кожне місце в словнику roads і якщо місце все ще є в словнику (не було видалено), то створюємо порожню множину для поточної компоненти і використовуємо стек для пошуку у глибину (DFS): `stack = [place]` .

Пошук у глибину: ми беремо останнє місце зі стеку і якщо місце ще не було оброблено, ми додаємо його до поточної компоненти, додаємо всі з'єднані місця в стек і видаляємо оброблене місце з розгляду, щоб не обробляти його знову. Згодом додаємо знайдену компоненту до замороженої множини компонент.

**Функція shortest_connection:**

Ця функція розроблена для знайдення найкоротших шляхів для відновлення зв'язку між не з’єднаними населеними пунктами. Для цього використовувався жадібний алгоритм, в якому шляхи оцінюються за довжиною доріг.

Спершу створюється копія множини заблокованих доріг, щоб не змінювати оригінальну `blocked = blocked.copy()` і множина для збереження доріг, які будуть відновлені `restored = set().`

Далі заходимо в цикл, який продовжується, поки не буде досягнуто бажаного результату. Ми витягуємо лише пари місць, де дороги заблоковані і викликаємо функцію для пошуку непідключених місць. Якщо є більше ніж одна компонента зв'язності, визначаємо від'єднані місця: об'єднуємо всі від’єднані компоненти, якщо ж компонента тільки одна, виходимо з циклу.

Далі визначаємо доступні місця, які з’єднані з першою компонентою, створюємо список можливих варіантів для з'єднання `options = []` . Для кожного доступного місця, для кожного від'єднаного місця і якщо існує шлях між ними, ми перевіряємо всі заблоковані дороги для можливості з'єднання і додаємо заблоковану дорогу в список варіантів.

Згодом ми сортуємо варіанти за вартістю відновлення дороги (за відстанню), вибираємо найменшу за вартістю дорогу для відновлення та видаляємо вибрану дорогу з заблокованих і додаємо її до відновлених

**Функція write_to_file:**

Ця функція створена для збереження оброблених результатів у файл. Після виконання всіх основних етапів алгоритмів, таких як пошук роз’єднаних населених пунктів та визначення найкоротших шляхів, ця функція дозволяє зберігати отримані дані для подальшого аналізу або для використання у майбутньому. Вона забезпечує зручний спосіб передачі результатів, які були отримані в процесі виконання програми, в текстовий файл. Ось як ця функція реалізована та що вона робить:

Спершу відкривається файл для запису та записується в файл заголовок **"Disconnected places:"**, а потім додає кожну групу незв'язаних місць із `disconnected` .

Згодом записується заголовок **"Restored roads:"** для кожної дороги з множини `restored`форматує дорогу як (наприклад, `city A, city B, 10`).

**Функція main:**
Вона об'єднує всі допоміжні функції та забезпечує їхнє виконання відповідно до параметрів, введених користувачем.

Використовується модуль `argparse` для обробки команд із терміналу.

- `--input` — дозволяє вказати вхідний файл.
- `--output` — дозволяє вказати вихідний файл.
    
    Тоді викликаються основні функції: спершу читає вхідний файл і повертає `all_roads` (словник з усіма доступними шляхами) і `blocked_roads` (множина заблокованих шляхів). Згодом фільтрує заблоковані дороги, знаходить групи місць, які не з’єднані між собою і знаходить найоптимальніші дороги для відновлення з мінімальною загальною довжиною.
    Викликається функція `write_to_file` і тоді записуємо всі нез’єднані місця до файлу і шляхи, які потрібно відновити.
    

**Функція visual:**

Функція visual у коді - створює візуалізацію графу, який репрезентує з’єднання між місцями з можливістю виділити заблоковані дороги. Візуалізація реалізована через бібліотеки `networkx` та `matplotlib`

Спершу `blocked_roads` та `restored_roads` (опціональний параметр) переводяться в словник для зручнішої взаємодії. Створюється обʼєкт класа граф `G` та в нього додаються всі ребра нашого графа. Потім визначаються кольори ребер: зруйновані дороги - червоні, відновлені (за наявності) - сині, недоторкані - зелені. Далі для кожної вершини створюємо репрезентативну назву, для зручності ігнорується тип населеного пункту, якщо це не регіональний центр: в такому випадку перед назвою додається `R.C.` (скорочено від Regional Center). Генеруємо розсташування вершин через вбудований метод та за допомоги створених змінних задаємо властивості графу: спочатку вершини та ребра, потім ваги ребер, потім назви населених пунктів. Задаємо відстань від країв та виводимо на екран користувача отриману візуалізацію.

**Функція ui:**

Ця функція відповідає за репрезентацію всіх можливих дій, які може виконати наш код:

- Visualize the graph (викликається функція def visual, яка показує початкову ситуацію зі всіма заблокованими дорогами).
- Find disconnected places (окремо виводяться всі н.п., які не є з’єднаними з регіональним центром).
- Find the best way to restore roads (виводиться оптимальний набір доріг, які потрібно відновити для вирішення проблеми).
- Visualize the best way to restore roads (викликається функція def visual, яка візуалізує на початковому графі відновлені дороги).
- Exit (завершує виконання програми).

## Розподіл роботи

1. **Кукурудза Вікторія**: Розробка функції `read_file`, яка зчитує дані з файлу та формує граф із вершинами (населені пункти) та ребрами (дороги). Функція також опрацьовує перелік заблокованих доріг.
2. **Кальмук Ярополк**: Створення функції `unconnected_places`, яка визначає всі населені пункти, що залишились без сполучення з обласним центром, і повертає список груп з'єднаних компонентів та функції `main` , яка об'єднує всі допоміжні функції та реалізовує `argparse`.
3. **Рихальський Михайло**: Розробка функції `shortest_connection` для пошуку оптимального набору доріг, які потрібно відновити для забезпечення з’єднання між усіма пунктами. Створення функції `ui`, що відповідає за зручний та простий інтерфейс користування. Доведення до працездатного стану функції `visual`, що відповідає за візуалізацію графу. Інтеграція всіх функцій між собою.
4. **Прокопець Максим**: Написання функції `write_to_file`, яка записує результати обчислень у вихідний файл. Початок створення функції `visual`, що відповідає за візуалізацію графу.
5. **Хімяк Вікторія**: Написання звіту та створення презентації, включаючи документування всіх етапів роботи та принципів, використаних у проєкті.

## Використані алгоритми та п**ринципи дискретної математики**

### **Граф**

Задача моделюється у вигляді **неорієнтованого** **графа**, де:

- **Вершини**: представляють місця (села, міста, обласний центр).
- **Ребра**: представляють дороги між місцями (з доступними відстанями).

У нашому завдання ми використовуємо словник для представлення зв'язків між вершинами, де ключі – це населені пункти (вершини), а значення – це множини інших населених пунктів, з якими вони з'єднані.

### Жадібний алгоритм

Жадібний алгоритм у контексті цього коду використовується в функції `shortest_connection`, де його основна ідея — поетапно вибирати найбільш вигідні (тобто з найменшими витратами) варіанти для відновлення зв'язків між відокремленими компонентами графу, доки всі компоненти не будуть з'єднані.

### Пошук у глибину

Пошук у глибину (DFS): ****використовується для обходу графа й виявлення всіх вершин, які можна досягти з початкової вершини. У функції `disconnected_places` реалізовано цей алгоритм. 
Алгоритм починається з вибору місця зі стека та пошуку всіх його пов'язаних місць, які ще не були відвідані. Всі знайдені пов'язані місця додаються до стека для подальшого дослідження. Кожне відвідане місце видаляється з графа, щоб уникнути його повторного відвідування. Таким чином, ми поступово обробляємо всі місця, з'єднані з початковим.

## Використання проєкту

Варто також було зрозуміти, що цей проєкт може бути використаний в різних реальних ситуаціях. Основна мета полягала в тому, щоб створити програму, яка допоможе вирішувати  проблеми з транспортною інфраструктурою та відновленням зв'язків між населеними пунктами в умовах критичних ситуацій, наприклад, після природних катастроф.

Іншим важливим застосуванням є аналіз транспортної інфраструктури для підвищення її ефективності. Проєкт можна використати для дослідження того, як зміни в мережі доріг (наприклад, будівництво нових шляхів або закриття наявних) впливають на доступність різних регіонів. Це допоможе оптимізувати маршрути доставки товарів або організацію пасажирських перевезень, зменшуючи витрати часу та ресурсів.

## Фідбек викладачам та асистентам

Викладачі на наших заняттях приділили значну увагу теоретичним основам, зокрема графам, їхнім властивостям, принципам і алгоритмам для аналізу. Ми більше дізналися про знаходження найкоротших шляхів, двочасткові графи та інше.

Щодо реалізації проєкту, ми отримали велику допомогу від асистентів. Вони надали цінні поради щодо роботи з графами, допомогли нам краще зрозуміти завдання, принципи алгоритмів та їхнє застосування до нашого завдання. 

## Враження від виконання

Виконання цього проєкту стало для нашої групи надзвичайно цікавим досвідом, який дозволив не тільки покращити наші знання з дискретної математики та програмування, але й навчив нас ефективно працювати в команді. Також ми зрозуміли важливість правильної організації роботи, обміну ідеями та спільного досягнення поставлених цілей.

Цей проєкт став чудовим прикладом того, як важлива командна робота в процесі розробки складних алгоритмів. Кожен із нас працював над окремою частиною завдання, але кожен етап був взаємопов'язаний з іншими. Ми поділили роботу таким чином, щоб максимально ефективно використовувати сильні сторони кожного члена групи. Вікторія займалася читанням і збереженням інформації з файлу, Ярополк працював над визначенням відрізаних населених пунктів, Михайло реалізував алгоритм для пошуку найкоротших шляхів, а Максим  забезпечував запис результатів у файл. Така організація дозволила мінімізувати помилки і ефективно використовувати час.

Як і в будь-якому проєкті, ми зіткнулися з певними труднощами. Основною складністю на початковому етапі стало узгодженням форматів вхідних і вихідних даних між різними модулями і згодом інтеграція всіх частин проєкту в єдину робочу систему. 

Особливо хочеться підкреслити роль асистентів у нашому успіху. Їхні поради та рекомендації були неймовірно корисними — вони допомогли нам розібратися з технічними деталями, уникнути зайвих помилок і зробити програму більш ефективною.

У кінцевому результаті, вже при повністю реалізованій програмі, ми змогли побачити, як всі частини працюють синхронно, і результат відповідає поставленим вимогам. Цей проєкт став для нашої групи не лише можливістю застосувати набуті знання, а й справжнім випробуванням. Ми навчились не лише розв’язувати різні задачі, але й ефективно взаємодіяти в команді, координувати дії і вирішувати проблеми, що виникають на шляху.
