# Служба швидкого реагування

Стихійні лиха, такі як повені чи цунамі, створюють серйозні проблеми для транспортної інфраструктури, особливо в регіонах, де населені пункти мають обмежену кількість доріг для сполучення. Відновлення зв’язності транспортної мережі є необхідним для забезпечення доступу до гуманітарної допомоги, евакуації та відновлення нормального життя.

Наш проєкт спрямований на вирішення цієї проблеми шляхом розробки програми, яка:
1. Визначає населені пункти, що залишилися без доступу до обласних центрів.
2. Знаходить мінімальну кількість доріг, які необхідно відновити для повного відновлення транспортного сполучення.

Протягом кількох тижнів, ми з командою працювали над реалізацією цього завдання. Нашою головною метою було створити програму, яка б не лише ефективно виконувала свою функцію, але й була зручною у використанні. Для найкращої реалізації цього завдання, ми розділили роботу на декілька етапів.

## Розподіл роботи

1. **Кукурудза Вікторія**: Розробка функції `read_file`, яка зчитує дані з файлу та формує граф із вершинами (населені пункти) та ребрами (дороги). Функція також опрацьовує перелік заблокованих доріг.
2. **Кальмук Ярополк**: Створення функції `unconnected_places`, яка визначає всі населені пункти, що залишились без сполучення з обласним центром, і повертає список груп з'єднаних компонентів.
3. **Рихальський Михайло**: Розробка функції `shortest_connection` для пошуку мінімального набору доріг, які потрібно відновити для забезпечення з’єднання між усіма пунктами.
4. **Прокопець Максим**: Написання функції `write_to_file`, яка записує результати обчислень у вихідний файл.
5. **Хімяк Вікторія**: Написання звіту, включаючи документування всіх етапів роботи та принципів, використаних у проєкті.

## **Процес виконання**

### **Визначення проблеми та обговорення ідей для її вирішення**

На першій зустрічі ми обговорили основні вимоги до проєкту та розподілили обов'язки. Метою було зрозуміти загальний контекст задачі та визначити, хто буде відповідати за які частини роботи. Під час цієї зустрічі ми також розглянули вхідні дані та їх структуру, що дозволило нам краще зрозуміти, як потрібно обробляти та зберігати інформацію.

Ми визначили, що формат вхідних даних буде наступним:
- Структура графа: Граф представляється у вигляді вершин (населені пункти) та ребер (дороги, з інформацією про їхню довжину).
- Блоковані дороги мають зберігатися окремо.

Ця перша зустріч була дуже важливою, оскільки це дозволило нам налаштувати комунікацію та обговорити всі аспекти завдання, що допомогло організувати подальшу роботу.

### **Розробка функцій**

Після першої зустрічі кожен з нас почав працювати над своїми частинами проєкту.

**Функція read_file:**

Спочатку було розроблено базову функцію для зчитування файлу, обробки та аналізу інформації про транспортні з'єднання між населеними пунктами. Вона працює з CSV-файлом, що містить дані про зв'язки між різними типами населених пунктів та довжини доріг між ними, а також зберігає інформацію про заблоковані дороги. Ось як ця функція реалізована та що вона робить:

Спершу функція відкриває файл у режимі читання та задаються змінні: `blocked` — збереження заблокованих доріг, `all_road` — збереження всіх доріг між місцями, `status_road` — булева змінна, яка визначає, чи ми зараз обробляємо звичайні дороги (True) чи заблоковані (False).

Цикл проходиться по кожній лінії та якщо у файлі зустрічається рядок "Blocked", функція змінює `status_road` на `False`, вказуючи, що всі наступні рядки описують заблоковані дороги.

Згодом рядок розбивається на частини (наприклад: рядок `"city A, village B, 10”` розбивається на `["city", "A", "village", "B", "10"]` та формуються ключі для міст (`key1` для першого міста:  `("city", "A")` ; `key2` для другого міста `("village", "B")`).

Якщо `status_road` — True: 

- якщо `key1` ще немає у словнику `all_road`, створюється новий запис, де `key1` є ключем, а `key2` — елементом множини, що представляє всі з'єднані місця.
- якщо `key1` уже існує в `all_road`, до множини з'єднань додається `key2`.

Аналогічно обробляється зворотний зв’язок, додаючи `key1` у список з'єднань для `key2`.

Якщо `status_road` — False: у множину `blocked` додається кортеж, який містить перше місто, друге місто та довжину дороги.

У результаті функція повертає список: перший елемент — словник `all_road`, що містить усі доступні дороги; другий елемент — множина `blocked`, що містить всі заблоковані дороги.

**Функція unconnected_places:**

Ця функція визначає всі відокремлені місця на основі наданих даних про з'єднання між ними та заблоковані дороги. Вона здійснює пошук компонент зв'язності в графі, що складається з місць, з’єднаних дорогами, причому заблоковані дороги не враховуються в пошуку.

Спершу створюємо порожній словник для зберігання фільтрованих з'єднань `roads = {}` . Згодом перебираємо кожне місце та його з'єднання: ми фільтруємо з'єднання, перевіряючи чи не є дорога заблокованою і записуємо відфільтровані з'єднання в новий словник.

Далі ми перебираємо кожне місце в словнику roads і якщо місце все ще є в словнику (не було видалено), то створюємо порожню множину для поточної компоненти і використовуємо стек для пошуку у глибину (DFS): `stack = [place]` .

Пошук у глибину: ми беремо останнє місце зі стеку і якщо місце ще не було оброблено, ми додаємо його до поточної компоненти, додаємо всі з'єднані місця в стек і видаляємо оброблене місце з розгляду, щоб не обробляти його знову. Згодом додаємо знайдену компоненту до списку компонент

**Функція shortest_connection:**

Ця функція розроблена для знайдення найкоротших шляхів для відновлення зв'язку між не з’єднаними населеними пунктами. Для цього використовувався алгоритм пошуку найкоротшого шляху, в якому шляхи оцінюються за довжиною доріг.

Спершу створюється копія множини заблокованих доріг, щоб не змінювати оригінальну `blocked = blocked.copy()` і множина для збереження доріг, які будуть відновлені `restored = set().`

Далі заходимо в цикл, який продовжується, поки не буде досягнуто бажаного результату. Ми витягуємо лише пари місць, де дороги заблоковані і викликаємо функцію для пошуку непідключених місць. Якщо є більше ніж одна компонента зв'язності, визначаємо від'єднані місця: об'єднуємо всі від’єднані компоненти, якщо ж компонента тільки одна, виходимо з циклу.

Далі визначаємо доступні місця, які з’єднані з першою компонентою, створюємо список можливих варіантів для з'єднання `options = []` . Для кожного доступного місця, для кожного від'єднаного місця і якщо існує шлях між ними, ми перевіряємо всі заблоковані дороги для можливості з'єднання і додаємо заблоковану дорогу в список варіантів.

Згодом ми сортуємо варіанти за вартістю відновлення дороги (за відстанню), вибираємо найменшу за вартістю дорогу для відновлення та видаляємо вибрану дорогу з заблокованих і додаємо її до відновлених

**Функція write_to_file:**

Ця функція створена для збереження оброблених результатів у файл. Після виконання всіх основних етапів алгоритмів, таких як пошук роз’єднаних населених пунктів та визначення найкоротших шляхів, ця функція дозволяє зберігати отримані дані для подальшого аналізу або для використання у майбутньому. Вона забезпечує зручний спосіб передачі результатів, які були отримані в процесі виконання програми, в текстовий файл. Ось як ця функція реалізована та що вона робить:

Спершу відкривається файл для запису та записується в файл заголовок **"Unconnected places:"**, а потім додає кожну групу незв'язаних місць із `unconnected` .

Згодом записується заголовок **"Restored roads:"** для кожної дороги з множини `restored`форматує дорогу як (наприклад, `city A, city B, 10`).

Під час цього етапу ми активно обговорювали та тестували написані функції. Якщо виникали проблеми, то ми швидко знаходили рішення через онлайн-чат. Це дозволило забезпечити ефективну співпрацю.

**Функція main:**
Остання функція у коді — це функція `main`. Вона об'єднує всі допоміжні функції та забезпечує їхнє виконання відповідно до параметрів, введених користувачем.

Використовується модуль `argparse` для обробки команд із терміналу.

- `-input` — дозволяє вказати вхідний файл.
- `-output` — дозволяє вказати вихідний файл.
    
    Тоді викликаються основні функції: спершу читає вхідний файл і повертає `all_roads` (словник з усіма доступними шляхами) і `blocked_roads` (множина заблокованих шляхів). Згодом фільтрує заблоковані дороги, знаходить групи місць, які не з’єднані між собою і знаходить найоптимальніші дороги для відновлення з мінімальною загальною довжиною.
    Викликається функція `write_to_file` і тоді записуємо всі нез’єднані місця до файлу і шляхи, які потрібно відновити.
    

## Використані алгоритми та п**ринципи дискретної математики**

### **Граф**

Задача моделюється у вигляді **неорієнтованого** **графа**, де:

- **Вершини**: представляють місця (села, міста, обласний центр).
- **Ребра**: представляють дороги між місцями (з доступними відстанями).

У нашому завдання ми використовуємо словник для представлення зв'язків між вершинами, де ключі – це місця (вершини), а значення – це множини місць, з якими вони з'єднані.

### Жадібний алгоритм

Жадібний алгоритм у контексті цього коду використовується в функції `shortest_connection`, де його основна ідея — поетапно вибирати найбільш вигідні (тобто з найменшими витратами) варіанти для відновлення зв'язків між відокремленими компонентами графу, доки всі компоненти не будуть з'єднані.

### Пошук у глибину

Пошук у глибину (DFS): використовується для обходу графа й виявлення всіх вершин, які можна досягти з початкової вершини. У функції `unconnected_places` реалізовано цей алгоритм. 
Алгоритм починається з вибору місця зі стека та пошуку всіх його пов'язаних місць, які ще не були відвідані. Всі знайдені пов'язані місця додаються до стека для подальшого дослідження. Кожне відвідане місце видаляється з графа, щоб уникнути його повторного відвідування. Таким чином, ми поступово обробляємо всі місця, з'єднані з початковим.

## Використання проєкту

Варто також було зрозуміти, що цей проєкт може бути використаний в різних реальних ситуаціях. Основна мета полягала в тому, щоб створити програму, яка допоможе вирішувати  проблеми з транспортною інфраструктурою та відновленням зв'язків між населеними пунктами в умовах критичних ситуацій, наприклад, після природних катастроф.

Іншим важливим застосуванням є аналіз транспортної інфраструктури для підвищення її ефективності. Проєкт можна використати для дослідження того, як зміни в мережі доріг (наприклад, будівництво нових шляхів або закриття наявних) впливають на доступність різних регіонів. Це допоможе оптимізувати маршрути доставки товарів або організацію пасажирських перевезень, зменшуючи витрати часу та ресурсів.

## Фідбек викладачам та асистентам

Викладачі на наших заняттях приділили значну увагу теоретичним основам, зокрема графам, їхнім властивостям, принципам і алгоритмам для аналізу. Ми більше дізналися про знаходження найкоротших шляхів, двочасткові графи та інше.

Щодо реалізації проєкту, ми отримали велику допомогу від асистентів. Вони надали цінні поради щодо роботи з графами, допомогли нам краще зрозуміти завдання, принципи алгоритмів та їхнє застосування до нашого завдання. 

## Враження від виконання

Виконання цього проєкту стало для нашої групи надзвичайно цікавим досвідом, який дозволив не тільки покращити наші знання з дискретної математики та програмування, але й навчив нас ефективно працювати в команді. Також ми зрозуміли важливість правильної організації роботи, обміну ідеями та спільного досягнення поставлених цілей.

Цей проєкт став чудовим прикладом того, як важлива командна робота в процесі розробки складних алгоритмів. Кожен із нас працював над окремою частиною завдання, але кожен етап був взаємопов'язаний з іншими. Ми поділили роботу таким чином, щоб максимально ефективно використовувати сильні сторони кожного члена групи. Вікторія займалася читанням і збереженням інформації з файлу, Ярополк працював над визначенням відрізаних населених пунктів, Михайло реалізував алгоритм для пошуку найкоротших шляхів, а Максим  забезпечував запис результатів у файл. Така організація дозволила мінімізувати помилки і ефективно використовувати час.

Як і в будь-якому проєкті, ми зіткнулися з певними труднощами. Основною складністю на початковому етапі стало узгодженням форматів вхідних і вихідних даних між різними модулями і згодом інтеграція всіх частин проєкту в єдину робочу систему. 

Особливо хочеться підкреслити роль асистентів у нашому успіху. Їхні поради та рекомендації були неймовірно корисними — вони допомогли нам розібратися з технічними деталями, уникнути зайвих помилок і зробити програму більш ефективною.

У кінцевому результаті, вже при повністю реалізованій програмі, ми змогли побачити, як всі частини працюють синхронно, і результат відповідає поставленим вимогам. Цей проєкт став для нашої групи не лише можливістю застосувати набуті знання, а й справжнім випробуванням. Ми навчились не лише розв’язувати різні задачі, але й ефективно взаємодіяти в команді, координувати дії і вирішувати проблеми, що виникають на шляху.
